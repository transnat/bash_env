#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Date:         August 09, 2022
# Description:
'''
Convert structured data between INI, HTML, JSON, YAML, XML.

Requirements:
'''

__author__ = 'Casey Sparks'
__install_requires__ = [
    'dict2xml>=1.7.2,<2.0.0',
    'pyjson',
    'pyyaml',
    'xmltodict'
]

from argparse import ArgumentParser, Namespace
from configparser import ConfigParser
from json import dumps as jdumps, load
from locale import setlocale, LC_ALL
from logging import getLogger, Formatter, RootLogger, StreamHandler
from pathlib import Path
from sys import exit as sys_exit, stdout
from typing import NoReturn, Tuple
from dict2xml import dict2xml
from xmltodict import parse
from yaml import safe_load, dump as ydump


setlocale(LC_ALL, 'en_US.UTF-8')                                            # Set locale.

ARGS, LOG = get_arguments()                                                 # Get arguments; instantiate logger.


def get_arguments() -> Tuple[Namespace, RootLogger]:
    '''
    Get cmdline arguments.
        :return:    Tuple containing user-provided commandline arguments, and instantiated root logger.
    '''
    def _get_logger(
        log_level: int = 30                                                 # Default INFO.
            ) -> RootLogger:
        '''
        Enable logging and handle outputs.
            :param log_level:   User-specified log level (10-50).
            :return:            Instantiated root logger.
        '''
        formatter = Formatter(                                              # Log header.
              '{asctime} {threadName:12} {levelname:8}: "{message}"',       # Format style.
              style='{'                                                     # Set f-string style formating.
        )
        handler = StreamHandler()                                           # Logging stream handler.
        logger = getLogger()                                                # Root logger class.

        handler.setFormatter(formatter)                                     # Set log stream format.
        logger.setLevel(log_level)                                          # User-specified log_level.
        logger.addHandler(handler)                                          # Log to screen.

        return logger

    parser = ArgumentParser(                                                # Instantiate argument parser.
        description='Convert structured data between JSON and YAML.'
    )

    parser.add_argument(                                                    # Read data from file.
        '--infile', '-i',
        dest='infile',
        type=Path,
        help='File to read from.'
    )
    parser.add_argument(                                                    # Specify an output format.
        '--format', '-f',
        dest='format',
        choices=['ini', 'json', 'xml', 'yaml'],
        default='yaml',
        type=str,
        help='Data format to output.'
    )
    parser.add_argument(                                                    # Output data to file.
        '--write', '-w',
        dest='write',
        action='store_true',
        help='Write file to disk instead of stdout.'
    )
    parser.add_argument(                                                    # Enable DEBUG logging.
        '--verbose', '-v',
        action='count',
        dest='log_level',
        default=0,                                                          # Default NOTSET.
        help='Set log level (default INFO).'
    )

    arguments = parser.parse_args()
    arguments.log_level = max(50 - arguments.log_level * 10, 10)
    logger = _get_logger(arguments.log_level)

    return arguments, logger


def ingest_data(
    infile: Path
        ) -> dict:
    '''
    Ingests a YAML or JSON object from a file or STDIN.
        :param infile:  The file to ingest data from.
        :return:        Dictionary containing parsed data.
    '''
    LOG.debug(f'Reading from file: {infile.name}')

    file_suffix = infile.suffix

    match file_suffix:
        case '.json':                                                       # JSON.
            payload = load(open(infile, 'r', encoding='utf-8'))

        case '.ini':                                                        # INI.
            config = ConfigParser()

            config.read(infile)

            payload = config._sections

        case '.html' | '.xml':                                              # HTML/XML.
            payload = parse(open(infile, 'r', encoding='utf-8').read())

        case '.yaml' | '.yml':                                              # Default to YAML.
            payload = safe_load(open(infile, 'r', encoding='utf-8'))

        case _:
            print('Unsupported filetype. Please check the extension and try again.')
            sys_exit(1)

    LOG.debug(
        f'Input: {infile}\n',
        f'Input filetype: {file_suffix.upper().replace(".", "")}\n\n',
        payload
    )

    return payload


def output_data(
    payload: dict,
    infile: Path,
    out_format: str,
    write: bool = False
        ) -> NoReturn:
    '''
    Formats and outputs a data object as JSON or YAML to a file or STDOUT.
        :param arguments:   User-specified commandline arguments.
        :param payload:     The Python dict to format and output.
    '''
    if write:                                                               # Write to file or stdout.
        outfile = open(infile.with_suffix(f'.{out_format}'), 'w', encoding='utf-8')

    else:
        outfile = stdout

    LOG.debug(f'Writing {out_format.upper()} output to {outfile.name}.')

    match out_format.lower():
        case 'ini':                                                         # INI.
            config = ConfigParser()                                         # Instantiate parser.

            for key in payload.keys():
                if iter(key):                                               # Keys are nested.
                    print('Warning! INI does not support nested values.\nValues will be flattened to strings.')

                    if input('Proceed? [y/N] ').lower().startswith('y'):    # ACK and continue.
                        break

                    sys_exit(1)

            config._sections = payload
            config.write(outfile)

        case 'json':                                                        # JSON.
            outfile.write(jdumps(
                payload,
                indent=2
            ))

        case 'html' | 'xml':                                                # XML.
            outfile.write(dict2xml(payload))

        case _:                                                             # Default to YAML.
            outfile.write(ydump(payload))


if __name__ == '__main__':
    output_data(
        ingest_data(ARGS.infile),
        ARGS.infile,
        ARGS.format,
        ARGS.write
    )
