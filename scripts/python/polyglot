#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Author:       Casey Sparks
# Date:         August 09, 2022
# Description:
'''
Convert structured data between JSON, YAML, and XML.

Requirements:
    * dict2xml
    * pyjson
    * pyyaml
    * xmltodict
'''

import argparse
import locale
import logging
import pathlib
import sys
from typing import NoReturn
import json
import xmltodict
import yaml
from configparser import ConfigParser
from dict2xml import dict2xml


locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')                      # Set locale.


def get_arguments() -> argparse.Namespace:
    '''Get cmdline arguments.'''
    parser = argparse.ArgumentParser(                               # Instantiate argument parser.
        description='Convert structured data between JSON and YAML.'
    )
    parser.add_argument(                                            # Read data from file.
        '-i', '--infile',
        dest='infile',
        type=pathlib.Path,
        help='File to read from.'
    )
    parser.add_argument(                                            # Output data to file.
        '-f', '--format',
        dest='format',
        choices=['ini', 'json', 'xml', 'yaml'],
        default='yaml',
        type=str,
        help='Data format to write to.'
    )
    parser.add_argument(                                            # Output data to file.
        '-w', '--write',
        dest='write',
        action='store_true',
        help='Write file to disk instead of stdout.'
    )
    parser.add_argument(                                            # Enable DEBUG logging.
        '-v', '--verbose',
        action='store_const',
        dest='loglevel',
        const=logging.DEBUG,
        default=logging.INFO,
        help='Set log level to DEBUG.'
    )

    return parser.parse_args()


def enable_logging(
    args: argparse.Namespace
        ) -> logging.RootLogger:
    '''
    Enable logging and handle outputs.
        :param args:    User-specified commandline arguments.
    '''
    log = logging.getLogger()                                           # Log to screen.

    log.setLevel(args.loglevel)                                         # User-specified loglevel.
    log.debug('Debug logging enabled.')

    return log


def ingest_data(
    args: argparse.Namespace,
        ) -> dict:
    '''
    Ingests a YAML or JSON object from a file or STDIN.
        :param args:    User-specified commandline arguments.
    '''
    log.debug(f'Reading from file: {args.infile.name}')

    try:                                                            # Try to ingest JSON.
        infiletype = 'json'
        payload = json.load(open(args.infile, 'r'))

    except json.decoder.JSONDecodeError:                            # Try to ingest XML.
        infiletype = 'xml'
        payload = xmltodict.parse(open(args.infile).read())

    except xmltodict.expat.XpatError:                               # Try to ingest INI.
        config = ConfigParser.ConfigParser()
        infile = 'ini'

        config.read(args.infile)

        payload = config._sections

    except MissingSectionHeader:                                    # Ingest YAML.
        # Note that yaml.safeload() will ingest **any** textfile as YAML without errors,
        # so it must always remain the last option.
        infiletype = 'yaml'
        payload = yaml.safe_load(open(args.infile, 'r'))

    log.debug(
        f'Input: {args.infile}\n',
        payload
    )

    return infiletype, payload


def output_data(
    args: argparse.Namespace,
    payload: dict
        ) -> NoReturn:
    '''
    Formats and outputs a data object as JSON or YAML to a file or STDOUT.
        :param args:        User-specified commandline arguments.
        :param payload:     The Python dict to format and output.
    '''
    if args.write:                                                  # Write to file.
        filename = args.infile.with_suffix(f'.{args.format}')
        outfile = open(filename, 'w')

        log.debug(f'Writing {args.format.upper()} output to {filename}.')

    else:                                                           # Write to stdout.
        outfile = sys.stdout
        log.debug(f'Writing {args.format.upper()} output to stdout.')

    match args.format.lower():
        case 'ini':
            config = ConfigParser()                                 # Instantiate parser.
            nested_keys = False                                     # Validity checker.

            for key in payload.keys():
                if iter(key):                                       # Check if keys are invalid types.
                    nested_keys = True                              # Mark invalid.

            if nested_keys:                                         # Warn the user.
                log.warning(
                    'Warning! INI does not support nested values.\n'
                    'Values will be flattened to strings.'
                )

                if input(                                           # Proceed anyway.
                    'Proceed? [y/N] '
                ).lower().startswith('y'):
                    pass
                else:
                    sys.exit(1)


            config._sections = payload
            config.write(outfile)

        case 'json':                                                # JSON.
            outfile.write(json.dumps(
                payload,
                indent=2
            ))

        case 'xml':                                                 # XML.
            outfile.write(dict2xml(payload))

        case _:                                                     # Default to YAML.
            outfile.write(yaml.dump(payload))


if __name__ == '__main__':
    args = get_arguments()
    log = enable_logging(args)
    infiletype, payload = ingest_data(args)

    output_data(args, payload)
