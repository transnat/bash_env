#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Author:       Casey Sparks
# Date:         May 03, 2022
# Description:
'''
Send a wake-on-LAN packet to the specified IP addresses.
'''

from argparse import ArgumentParser, Namespace
from locale import setlocale, LC_ALL
from logging import getLogger, StreamHandler, DEBUG, INFO
from pathlib import Path
from socket import socket, AF_INET, SOCK_DGRAM, SOL_SOCKET, SO_BROADCAST
from sys import stderr
from pprint import pp
from subprocess import run
from typing import NoReturn, Tuple
from yaml import safe_load

# Enable logging, set locale, set args.
log = getLogger()

setlocale(LC_ALL, 'en_US.UTF-8')
log.addHandler(StreamHandler())
log.setLevel(INFO)


def get_arguments() -> Namespace:
    '''Get cmdline arguments.'''
    parser = ArgumentParser(
        description='Send a wake-on-LAN packet to specified MAC addresses.'
    )

    parser.add_argument(                                                    # The LAN interface.
        '--interface', '-i',
        dest='interface',
        nargs=1,
        default=Network.get_default_interface(),
        help='Specify the broadcast IP address.'
    )
    parser.add_argument(                                                    # The broadcast IP address.
        '--broadcast', '-b',
        dest='broadcast',
        nargs=1,
        default='255.255.255.255',
        help='Specify the broadcast IP address.'
    )
    parser.add_argument(                                                    # The port to use.
        '--port', '-p',
        dest='port',
        nargs=1,
        default=9,
        help='Specify the port to use.'
    )
    parser.add_argument(                                                    # STDIN-specified MAC addresses.
        '--macs', '-M',
        dest='macs',
        nargs='+',
        help='Specify a list of MAC addresses to send WoL packets to.'
    )
    parser.add_argument(                                                    # STDIN-specified hosts.
        '--hosts', '-H',
        dest='hosts',
        nargs='+',
        help='Specify a list of known hosts to send WoL packets to.'
    )
    parser.add_argument(                                                    # Get application info.
        '--info',
        action='store_true',
        dest='info',
        help='Print the default configuration and exit.'
    )
    parser.add_argument(                                                    # Enable DEBUG logging.
        '--verbose', '-v',
        action='store_const',
        dest='loglevel',
        const=DEBUG,
        help='Set log level to DEBUG.'
    )

    args = parser.parse_args()

    if args.info:                                                           # Print application info and exit.
        print_info(args)
        exit()

    if args.loglevel:                                                       # Set verbose logging.
        log.setLevel(args.loglevel)

    if not args.hosts and not args.macs:
        parser.print_help(stderr)
        exit()

    return args


def print_info(
    args: Namespace
        ) -> NoReturn:
    '''
    Print known hosts and configuration.
        :param args: User-specified commandline arguments.
    '''
    known_hosts, hostsfile = file_checks()
    iface_table = [                                                         # Interface information.
        ['Interface', args.interface],
        ['Broadcast', args.broadcast],
        ['Port', args.port]
    ]
    known_hosts = [[k, v] for k, v in known_hosts.items()]                  # Known hosts information.

    print('---------------------------------')                              # Print formatted tables.
    print('Interface Info')
    print('---------------------------------')

    for row in iface_table:
        print(f'{row[0]}:'.ljust(10) + f'{row[1]}'.rjust(23))

    print('\n---------------------------------')
    print('''Known Hosts\n---------------------------------''')

    for row in known_hosts:
        print(f'{row[0]}:'.ljust(10) + f'{row[1]}'.rjust(21))


def file_checks() -> Tuple[dict, Path]:
    '''Check for config directory/file, and create them if they do not exist.'''
    config_dir = Path(Path.home() / '.config/wakeonlan')                    # Directory for config files.
    hostsfile = config_dir / 'known_hosts.yml'                              # File containing known host mappings.
    known_hosts = list()

    if not config_dir.exists():                                             # Create config dir.
        log.debug(f'Creating config directory at {config_dir}.')
        config_dir.mkdir(
            parents=True,
            mode=0o755,
            exist_ok=True
        )

    if not hostsfile.exists():                                              # Create known hosts file.
        log.debug(f'Creating config file at {hostsfile}.')
        hostsfile.touch(mode=0o644, exist_ok=True)

    known_hosts = safe_load(open(hostsfile, 'rb'))                          # Read hosts file into var.

    return known_hosts, hostsfile


class Network():
    @staticmethod
    def get_mac_addresses(
        args: Namespace
            ) -> list:
        '''
        Grok stdin and config files for the hosts to wake.
            :param args: User-provided cmdline arguments.
        '''
        known_hosts, hostsfile = file_checks()                              # Get known hosts from config file.
        mac_addresses = list()

        if args.macs:                                                       # Set hosts based on MACs from STDIN.
            mac_addresses.append(args.macs)

        if args.hosts:                                                      # Set hosts based on hostnames from STDIN.
            for host in args.hosts:
                try:
                    mac_addresses.append(known_hosts[host])

                except TypeError:
                    log.critical(f'Config file {hostsfile} is empty.')

        log.debug(f'MAC addresses: {pp(mac_addresses)}')

        return mac_addresses

    @staticmethod
    def get_default_interface() -> str:
        '''Return the default network interface.'''
        interface = run(                                                    # Run subprocess to capture interface.
            ['ip', 'route', 'show'],
            capture_output=True
        ).stdout.decode('utf-8').split()[4]

        return interface

    @staticmethod
    def magic_packet(
        mac_address: str
            ) -> bytes:
        '''
        Create a magic packet used to wake a LAN device.
            :param macaddress: The MAC address that should be parsed into a magic packet.
        '''
        log.debug(f'Checking validity of MAC address: {mac_address}')

        if len(mac_address) == 17:                                          # Check/reformat MAC address.
            mac_address = mac_address.replace(mac_address[2], '')

        elif len(mac_address) != 12:
            log.critical(f'Invalid MAC address: {mac_address}')

            raise ValueError('Incorrect MAC address format.')

        return bytes.fromhex('F' * 12 + mac_address * 16)                   # Magic packet.

    @staticmethod
    def send_packet(
        mac_addresses: list,
        broadcast_ip: str,
        port: int,
        interface: str
            ) -> NoReturn:
        '''
        Send a network packet to a socket.
            :param mac_address:     The MAC address to send the packet to.
            :param broadcast_ip:    The broadcast IP of your subnet.
            :param port:            The port to send the packet to.
            :param interface:       The network interface to bind the socket to.
        '''
        log.debug('Instantiating socket.')

        with socket(AF_INET, SOCK_DGRAM) as sock:
            log.debug(f'Binding to interface {interface}.')
            sock.bind((interface, 0))
            log.debug('Setting socket options.')
            sock.setsockopt(                                                # Set socket options.
                SOL_SOCKET,
                SO_BROADCAST, 1
            )
            log.debug(f'Created {sock.type.name} socket.')
            log.debug('Connecting to socket.')
            sock.connect((broadcast_ip, port))                              # Connect to socket.
            log.debug('Connected.')

            for mac_address in mac_addresses:                               # Send magic packet.
                sent = sock.send(Network.magic_packet(mac_address))

                log.info(f'Sent: {sent}')


if __name__ == '__main__':
    args = get_arguments()

    Network.send_packet(
        mac_addresses=Network.get_mac_addresses(args),
        broadcast_ip=args.broadcast,
        port=args.port,
        interface=args.interface
    )
