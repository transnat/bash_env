#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Author:       Casey Sparks
# Date:         May 03, 2022
# Description:
'''
Send a wake-on-LAN packet to the specified IP addresses.
'''

import argparse
import locale
import logging
import pathlib
import socket
from pprint import pp
from subprocess import run
from typing import NoReturn, Tuple
import yaml

# Enable logging, set locale, set args.
log = logging.getLogger()

locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')
log.addHandler(logging.StreamHandler())
log.setLevel(logging.INFO)


def get_arguments() -> argparse.Namespace:
    '''Get cmdline arguments.'''
    parser = argparse.ArgumentParser(
        description='Send a wake-on-LAN packet to specified MAC addresses.'
    )

    parser.add_argument(                                        # The LAN interface.
        '--interface', '-i',
        dest='interface',
        nargs=1,
        default=get_default_interface(),
        help='Specify the broadcast IP address.'
    )
    parser.add_argument(                                        # The broadcast IP address.
        '--broadcast', '-b',
        dest='broadcast',
        nargs=1,
        default='255.255.255.255',
        help='Specify the broadcast IP address.'
    )
    parser.add_argument(                                        # The port to use.
        '--port', '-p',
        dest='port',
        nargs=1,
        default=9,
        help='Specify the port to use.'
    )
    parser.add_argument(                                        # STDIN-specified MAC addresses.
        '--macs', '-M',
        dest='macs',
        nargs='+',
        help='Specify a list of MAC addresses to send WoL packets to.'
    )
    parser.add_argument(                                        # STDIN-specified hosts.
        '--hosts', '-H',
        dest='hosts',
        nargs='+',
        help='Specify a list of known hosts to send WoL packets to.'
    )
    parser.add_argument(                                        # Get application info.
        '--info',
        action='store_true',
        dest='info',
        help='Print the default configuration and exit.'
    )
    parser.add_argument(                                        # Enable DEBUG logging.
        '--verbose', '-v',
        action='store_const',
        dest='loglevel',
        const=logging.DEBUG,
        help='Set log level to DEBUG.'
    )

    args = parser.parse_args()

    if args.info:                                               # Print application info and exit.
        print_info(args)
        exit()

    if args.loglevel:                                           # Set verbose logging.
        log.setLevel(args.loglevel)

    return args


def get_default_interface() -> str:
    interface = run(                                            # Run subprocess to capture interface.
        ['ip', 'route', 'show'],
        capture_output=True
    ).stdout.decode('utf-8').split()[4]

    return interface


def print_info(args: argparse.Namespace) -> NoReturn:
    known_hosts, hostsfile = file_checks()

    iface_table = [                                             # Interface information.
        ['Interface', args.interface],
        ['Broadcast', args.broadcast],
        ['Port', args.port]
    ]
    known_hosts = [[k, v] for k, v in known_hosts.items()]      # Known hosts information.

    print('---------------------------------')                  # Print formatted tables.
    print('''Interface Info\n---------------------------------''')

    for row in iface_table:
        print(f'{row[0]}:'.ljust(10) + f'{row[1]}'.rjust(23))

    print('\n---------------------------------')
    print('''Known Hosts\n---------------------------------''')

    for row in known_hosts:
        print(f'{row[0]}:'.ljust(10) + f'{row[1]}'.rjust(21))


def file_checks() -> Tuple[dict, pathlib.PosixPath]:
    '''Check for config directory/file, and create them if they do not exists.'''
    config_dir = pathlib.Path(                                  # Directory for config files.
        pathlib.Path.home() / '.config/wakeonlan'
    )
    hostsfile = config_dir / 'known_hosts.yml'                  # File containing known host mappings.
    known_hosts = list()

    if not config_dir.exists():                                 # Create config dir.
        log.debug(f'Creating config directory at {config_dir}.')
        config_dir.mkdir(
            parents=True,
            mode=0o755,
            exist_ok=True
        )

    if not hostsfile.exists():                                  # Create known hosts file.
        log.debug(f'Creating config file at {hostsfile}.')
        hostsfile.touch(mode=0o644, exist_ok=True)

    known_hosts = yaml.safe_load(open(hostsfile, 'rb'))         # Read hosts file into var.

    return known_hosts, hostsfile


def get_mac_addresses(
        args: argparse.Namespace
        ) -> list:
    '''
    Grok STDIN and config files for the hosts to wake.
        :param args: User-provided cmdline arguments.
    '''
    known_hosts, hostsfile = file_checks()                      # Get known hosts from config file.
    mac_addresses = list()

    if args.macs:                                               # Set hosts based on MACs from STDIN.
        mac_addresses = args.macs

    elif args.hosts:                                            # Set hosts based on hostnames from STDIN.
        for host in args.hosts:
            try:
                mac_addresses.append(known_hosts[host])
            except TypeError:
                log.critical(f'Config file {hostsfile} is empty.')

    else:                                                       # Exit.
        log.info('No hosts/MAC addresses provided. Exiting.')
        exit()

    log.debug(f'MAC addresses: {pp(mac_addresses)}')

    return mac_addresses


def magic_packet(
        mac_address: str
        ) -> bytes:
    '''
    Create a magic packet.
        :param macaddress: The MAC address that should be parsed into a magic packet.
    '''
    log.debug(f'Checking validity of MAC address: {mac_address}')

    if len(mac_address) == 17:                                  # Check/reformat MAC address.
        mac_address = mac_address.replace(mac_address[2], '')
    elif len(mac_address) != 12:
        log.critical(f'Invalid MAC address: {mac_address}')
        raise ValueError('Incorrect MAC address format.')

    return bytes.fromhex('F' * 12 + mac_address * 16)           # Magic packet.


def send_packet(
        mac_addresses: list,
        broadcast_ip: str,
        port: int,
        interface: str = None
        ) -> NoReturn:
    '''
    Send a network packet to a socket.
        :param mac_address:     The MAC address to send the packet to.
        :param broadcast_ip:    The broadcast IP of your subnet.
        :param port:            The port to send the packet to.
        :param interface:       The network interface to bind the socket to.
    '''
    log.debug('Instantiating socket.')

    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        if interface is not None:                               # Bind to the specified interface.
            log.debug(f'Binding to interface {interface}.')
            sock.bind((interface, 0))

        log.debug('Setting socket options.')
        sock.setsockopt(                                        # Set socket options.
            socket.SOL_SOCKET,
            socket.SO_BROADCAST, 1
        )
        log.debug(f'Created {sock.type.name} socket.')
        log.debug('Connecting to socket.')
        sock.connect((broadcast_ip, port))                      # Connect to socket.
        log.debug('Connected.')

        for mac_address in mac_addresses:
            sent = sock.send(magic_packet(mac_address))         # Send magic packet.

            log.info(f'Sent: {sent}')


if __name__ == '__main__':
    args = get_arguments()                                      # Get cmdline arguments.

    send_packet(                                                # Send magic packet to hosts.
        mac_addresses=get_mac_addresses(args),
        broadcast_ip=args.broadcast,
        port=args.port,
        interface=args.interface
    )
